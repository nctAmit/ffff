# OLD (WRONG FRAME):
# verts_model, faces = submesh_for_tile(tris_model, node.tri_ids)
# faces = flip_winding_if_needed(verts_model, faces, up_axis='Y')
# norms = compute_normals(verts_model, faces)
# write_glb(glb_path, verts_model, norms, faces)

# NEW (CONSISTENT Z-up CONTENT):
verts_tile, faces = submesh_for_tile(tris_tile, node.tri_ids)
if not faces:
    return None

# For Z-up content, ensure front faces point +Z
faces = flip_winding_if_needed(verts_tile, faces, up_axis='Z')

# Recompute normals in the same frame we export
norms = compute_normals(verts_tile, faces)

subdir = os.path.join(OUT_DIR, TILES_DIR, str(node.level), str(node.ix), str(node.iy))
glb_path = os.path.join(subdir, "tile.glb")
write_glb(glb_path, verts_tile, norms, faces)   # <-- export Z-up
content_uri = os.path.relpath(glb_path, OUT_DIR).replace("\\", "/")

# Bounding box is already computed from tris_tile (Z-up) below
verts_tile_for_bv, _ = submesh_for_tile(tris_tile, node.tri_ids)
aabb = aabb_of_vertices(verts_tile_for_bv)
box = box_from_aabb(aabb)





  def triangle_area_3d(tri, eps=1e-12):
    (x1,y1,z1),(x2,y2,z2),(x3,y3,z3) = tri
    ux, uy, uz = x2-x1, y2-y1, z2-z1
    vx, vy, vz = x3-x1, y3-y1, z3-z1
    # 0.5 * |u Ã— v|
    cx, cy, cz = (uy*vz - uz*vy), (uz*vx - ux*vz), (ux*vy - uy*vx)
    return 0.5 * math.sqrt(cx*cx + cy*cy + cz*cz)

# ...inside parse_tin_to_triangles(...)
# replace the fan triangulation check
if len(ring) >= 3:
    for i in range(1, len(ring) - 1):
        tri = [ring[0], ring[i], ring[i+1]]
        if triangle_area_3d(tri) > 1e-10:   # robust 3D area
            tris.append(tri)
