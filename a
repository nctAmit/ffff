




# Output root
OUT_DIR = "out_tileset"
TILES_DIR = "tiles"  # nested folders here
ROOT_TILE_FILENAME = "tileset.json"

# Tiling params
MAX_TRIS_PER_TILE = 400   # stop splitting when <= this many tris
MAX_DEPTH = 8             # hard limit of quadtree depth

# CRS settings
INPUT_EPSG = 3857
WGS84_EPSG = 4326
ECEF_EPSG = 4978

def enu_axes(lon: float, lat: float):
    lam, phi = math.radians(lon), math.radians(lat)
    sinl, cosl = math.sin(lam), math.cos(lam)
    sinp, cosp = math.sin(phi), math.cos(phi)
    E = (-sinl,  cosl, 0.0)
    N = (-sinp * cosl, -sinp * sinl, cosp)
    U = ( cosp * cosl,  cosp * sinl, sinp)
    return E, N, U

def proj_xy_to_lonlat(x: float, y: float) -> Tuple[float, float]:
    tr = Transformer.from_crs(f"EPSG:{INPUT_EPSG}", f"EPSG:{WGS84_EPSG}", always_xy=True)
    return tr.transform(x, y)


def enu_to_ecef_transform(lon: float, lat: float, h: float) -> List[float]:
    # Local basis in ECEF
    (ex, ey, ez), (nx, ny, nz), (ux, uy, uz) = enu_axes(lon, lat)
    # TILE FRAME: X=E, Y=N, Z=U  (Z-up)
    col0 = (ex, ey, ez)   # X -> East
    col1 = (nx, ny, nz)   # Y -> North
    col2 = (ux, uy, uz)   # Z -> Up
    X0, Y0, Z0 = (
        Transformer.from_crs(f"EPSG:{WGS84_EPSG}", f"EPSG:{ECEF_EPSG}", always_xy=True)
        .transform(lon, lat, h)
    )

    # Column-major 4x4
    return [
        col0[0], col0[1], col0[2], 0.0,
        col1[0], col1[1], col1[2], 0.0,
        col2[0], col2[1], col2[2], 0.0,
        X0,      Y0,      Z0,      1.0
    ]


# ---------- TIN -> triangles ----------
def triangle_area_xy(tri):
    (x1,y1,_),(x2,y2,_),(x3,y3,_) = tri
    return abs(0.5*((x2-x1)*(y3-y1) - (x3-x1)*(y2-y1)))

def parse_tin_to_triangles(tin: Any) -> List[List[Tuple[float,float,float]]]:
    tris = []
    def clean_ring(ring):
        out=[]; last=None
        for p in ring:
            t=(float(p[0]), float(p[1]), float(p[2]))
            if last is None or t!=last:
                out.append(t); last=t
        if len(out)>=2 and out[0]==out[-1]:
            out.pop()
        return out
    def walk(node):
        if not isinstance(node, list): return
        if len(node)>0 and isinstance(node[0], (list,tuple)) and len(node[0])>=3 and isinstance(node[0][0], (float,int)):
            ring=clean_ring(node)
            if len(ring)>=3:
                for i in range(1,len(ring)-1):
                    tri=[ring[0], ring[i], ring[i+1]]
                    if triangle_area_xy(tri)>0: tris.append(tri)
            return
        for c in node: walk(c)
    walk(tin)
    return tris

# ---------- Mesh helpers ----------
def build_indexed_mesh(tris):
    vmap: Dict[Tuple[float,float,float], int] = {}
    verts: List[Tuple[float,float,float]] = []
    faces: List[Tuple[int,int,int]] = []
    def add_v(p):
        idx = vmap.get(p)
        if idx is None:
            idx=len(verts); verts.append(p); vmap[p]=idx
        return idx
    for t in tris:
        i0=add_v(t[0]); i1=add_v(t[1]); i2=add_v(t[2])
        if len({i0,i1,i2})==3:
            faces.append((i0,i1,i2))
    return verts, faces

def compute_normals(verts: List[Tuple[float, float, float]],
                    faces: List[Tuple[int, int, int]]) -> List[Tuple[float, float, float]]:
    nx = [0.0] * len(verts)
    ny = [0.0] * len(verts)
    nz = [0.0] * len(verts)
    for i0, i1, i2 in faces:
        x0, y0, z0 = verts[i0]
        x1, y1, z1 = verts[i1]
        x2, y2, z2 = verts[i2]
        ux, uy, uz = x1 - x0, y1 - y0, z1 - z0
        vx, vy, vz = x2 - x0, y2 - y0, z2 - z0
        cx, cy, cz = uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx  # area-weighted
        nx[i0] += cx; ny[i0] += cy; nz[i0] += cz
        nx[i1] += cx; ny[i1] += cy; nz[i1] += cz
        nx[i2] += cx; ny[i2] += cy; nz[i2] += cz
    out = []
    for i in range(len(verts)):
        L = math.sqrt(nx[i] * nx[i] + ny[i] * ny[i] + nz[i] * nz[i]) or 1.0
        out.append((nx[i] / L, ny[i] / L, nz[i] / L))
    return out

def face_normal(vertices: List[Tuple[float, float, float]], i0: int, i1: int, i2: int) -> Tuple[float, float, float]:
    x0, y0, z0 = vertices[i0]
    x1, y1, z1 = vertices[i1]
    x2, y2, z2 = vertices[i2]
    ux, uy, uz = x1 - x0, y1 - y0, z1 - z0
    vx, vy, vz = x2 - x0, y2 - y0, z2 - z0
    return (uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx)

def flip_winding_if_needed(verts: List[Tuple[float, float, float]],
                           faces: List[Tuple[int, int, int]],
                           up_axis: str = 'Y') -> List[Tuple[int, int, int]]:
    """
    Ensure each triangle's front face points toward +Up.
    For glTF Y-up we want normal.y >= 0. Flip any that face down.
    """
    up_index = {'X': 0, 'Y': 1, 'Z': 2}[up_axis]
    fixed = []
    for (i0, i1, i2) in faces:
        n = face_normal(verts, i0, i1, i2)
        if n[up_index] < 0:
            fixed.append((i0, i2, i1))  # flip
        else:
            fixed.append((i0, i1, i2))
    return fixed

def write_glb(path: str,
              vertices: List[Tuple[float, float, float]],
              normals: List[Tuple[float, float, float]],
              indices: List[Tuple[int, int, int]]) -> None:
    os.makedirs(os.path.dirname(path), exist_ok=True)

    # Interleave buffers (packed, no stride)
    pos = b"".join(struct.pack("<fff", *v) for v in vertices)
    nor = b"".join(struct.pack("<fff", *n) for n in normals)
    flat = [i for tri in indices for i in tri]
    use_u16 = (max(flat) if flat else 0) < 65536
    if use_u16:
        ib = b"".join(struct.pack("<H", i) for i in flat); itype = 5123  # UNSIGNED_SHORT
    else:
        ib = b"".join(struct.pack("<I", i) for i in flat); itype = 5125  # UNSIGNED_INT

    def align4(n: int) -> int:
        return (n + 3) & ~3

    # Buffer layout with 4-byte alignment
    pos_off = 0
    pos_len = len(pos)
    nor_off = align4(pos_off + pos_len)
    nor_pad = b"\0" * (nor_off - (pos_off + pos_len))
    idx_off = align4(nor_off + len(nor))
    idx_pad = b"\0" * (idx_off - (nor_off + len(nor)))
    bin_blob = pos + nor_pad + nor + idx_pad + ib
    bin_blob += b"\0" * ((4 - len(bin_blob) % 4) % 4)

    # Accessors (POSITION min/max)
    xs = [v[0] for v in vertices]; ys = [v[1] for v in vertices]; zs = [v[2] for v in vertices]
    pos_min = [min(xs), min(ys), min(zs)] if vertices else [0, 0, 0]
    pos_max = [max(xs), max(ys), max(zs)] if vertices else [0, 0, 0]

    gltf = {
        "asset": {"version": "2.0", "generator": "tin_to_quadtree_tileset.py"},
        "scenes": [{"nodes": [0]}],
        "nodes": [{"mesh": 0}],
        "meshes": [{
            "primitives": [{
                "attributes": {"POSITION": 0, "NORMAL": 1},
                "indices": 2,
                "material": 0
            }]
        }],
        "materials": [{
            "doubleSided": True,  # Set False if you trust winding and want culling
            "pbrMetallicRoughness": {"metallicFactor": 0.0, "roughnessFactor": 1.0}
        }],
        "buffers": [{"byteLength": len(bin_blob)}],
        "bufferViews": [
            {"buffer": 0, "byteOffset": pos_off, "byteLength": pos_len,          "target": 34962},
            {"buffer": 0, "byteOffset": nor_off, "byteLength": len(nor),         "target": 34962},
            {"buffer": 0, "byteOffset": idx_off, "byteLength": len(ib),          "target": 34963},
        ],
        "accessors": [
            {"bufferView": 0, "byteOffset": 0, "componentType": 5126, "count": len(vertices), "type": "VEC3",
             "min": pos_min, "max": pos_max},
            {"bufferView": 1, "byteOffset": 0, "componentType": 5126, "count": len(normals),  "type": "VEC3"},
            {"bufferView": 2, "byteOffset": 0, "componentType": itype, "count": len(flat),    "type": "SCALAR"},
        ]
    }

    jb = json.dumps(gltf, separators=(",", ":"), ensure_ascii=False).encode("utf-8")
    jb += b" " * ((4 - len(jb) % 4) % 4)
    glb_len = 12 + 8 + len(jb) + 8 + len(bin_blob)

    with open(path, "wb") as f:
        f.write(struct.pack("<I", 0x46546C67))  # 'glTF'
        f.write(struct.pack("<I", 2))           # version 2
        f.write(struct.pack("<I", glb_len))
        f.write(struct.pack("<I", len(jb)));        f.write(b"JSON"); f.write(jb)
        f.write(struct.pack("<I", len(bin_blob)));  f.write(b"BIN\0"); f.write(bin_blob)

@dataclass
class TileNode:
    level: int
    ix: int
    iy: int
    xmin: float
    ymin: float
    xmax: float
    ymax: float
    tri_ids: List[int]
    children: List["TileNode"]


def rotate_yup_to_zup(p):
    """
    Rotate +90Â° around X to convert Y-up -> Z-up.
    (x, y, z) -> (x, -z, y)
    """
    x, y, z = p
    return (x, -z, y)

def tri_centroid_xy(tri):
    # Horizontal plane is X-Y in Z-up tile space (E-N)
    cx = (tri[0][0] + tri[1][0] + tri[2][0]) / 3.0
    cy = (tri[0][1] + tri[1][1] + tri[2][1]) / 3.0
    return (cx, cy)



def build_quadtree(tris_local: List[List[Tuple[float, float, float]]],
                   root_bounds: Tuple[float, float, float, float],
                   max_tris: int,
                   max_depth: int) -> TileNode:
    xmin, ymin, xmax, ymax = root_bounds
    root = TileNode(0, 0, 0, xmin, ymin, xmax, ymax, list(range(len(tris_local))), [])

    def split(node: TileNode) -> None:
        if node.level >= max_depth or len(node.tri_ids) <= max_tris:
            return
        cx = (node.xmin + node.xmax) * 0.5
        cy = (node.ymin + node.ymax) * 0.5

        buckets: Dict[int, List[int]] = {0: [], 1: [], 2: [], 3: []}  # NW, NE, SW, SE in (X,Z)
        for tid in node.tri_ids:
            x, z = tri_centroid_xy(tris_local[tid])
            if   x < cx and z >= cy: q = 0  # NW
            elif x >= cx and z >= cy: q = 1 # NE
            elif x < cx and z <  cy: q = 2  # SW
            else:                     q = 3  # SE
            buckets[q].append(tid)

        node.children = []
        # Child bounds in (X,Z)
        child_defs = [
            (0, node.xmin, cy,       cx,       node.ymax),  # NW
            (1, cx,        cy,       node.xmax, node.ymax), # NE
            (2, node.xmin, node.ymin, cx,       cy),        # SW
            (3, cx,        node.ymin, node.xmax, cy),       # SE
        ]
        for q, _, xmin_c, ymin_c, xmax_c, ymax_c in [(q, q, *b) for q, *b in [(0, node.xmin, cy,        cx,        node.ymax),
                                                                               (1, cx,       cy,        node.xmax, node.ymax),
                                                                               (2, node.xmin, node.ymin, cx,       cy),
                                                                               (3, cx,       node.ymin, node.xmax, cy)]]:
            dx = 0 if q in (0, 2) else 1
            dy = 1 if q in (0, 1) else 0
            child = TileNode(node.level + 1, node.ix * 2 + dx, node.iy * 2 + dy,
                             xmin_c, ymin_c, xmax_c, ymax_c, buckets[q], [])
            if child.tri_ids:
                node.children.append(child)

        for c in node.children:
            split(c)

        if node.children:
            node.tri_ids = []

    split(root)
    return root

def submesh_for_tile(tris_local, tri_ids):
    vmap: Dict[Tuple[float, float, float], int] = {}
    verts: List[Tuple[float, float, float]] = []
    faces: List[Tuple[int, int, int]] = []
    for tid in tri_ids:
        tri = tris_local[tid]
        idx: List[int] = []
        for p in tri:
            i = vmap.get(p)
            if i is None:
                i = len(verts); verts.append(p); vmap[p] = i
            idx.append(i)
        if len(set(idx)) == 3:
            faces.append((idx[0], idx[1], idx[2]))
    return verts, faces

def aabb_of_vertices(verts):
    if not verts:
        return (0, 0, 0, 1, 1, 1)
    xs = [v[0] for v in verts]; ys = [v[1] for v in verts]; zs = [v[2] for v in verts]
    return (min(xs), min(ys), min(zs), max(xs), max(ys), max(zs))

def box_from_aabb(aabb):
    xmin, ymin, zmin, xmax, ymax, zmax = aabb
    cx = (xmin + xmax) / 2; cy = (ymin + ymax) / 2; cz = (zmin + zmax) / 2
    hx = (xmax - xmin) / 2; hy = (ymax - ymin) / 2; hz = (zmax - zmin) / 2
    # 12-number OBB in local coords (axis-aligned here)
    return [cx, cy, cz,  hx, 0, 0,  0, hy, 0,  0, 0, hz]

def write_tileset_json(path, root_dict):
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        json.dump(root_dict, f, indent=2)


def get_result(result, features, design_file_name, redis_key, design_id):
    if result and len(result) > 0:
        output_json = {"type": "MultiPolygon", "coordinates": []}

        for data in result:
            tris_raw = parse_tin_to_triangles(json.loads(data[0])['coordinates'])
            if not tris_raw:
                raise ValueError("No triangles parsed from TIN")

            xs = [p[0] for t in tris_raw for p in t]
            ys = [p[1] for t in tris_raw for p in t]
            zs = [p[2] for t in tris_raw for p in t]
            x0 = sum(xs) / len(xs)
            y0 = sum(ys) / len(ys)
            h0 = sum(zs) / len(zs)
            lon0, lat0 = proj_xy_to_lonlat(x0, y0)

            tris_enu = [[(p[0] - x0, p[1] - y0, p[2] - h0) for p in tri] for tri in tris_raw]

            # 1) MODEL vertices for GLB (Y-up): X=E, Y=U, Z=-N
            def enu_to_model(p):
                E, N, U = p
                return (E, U, -N)

            tris_model = [[enu_to_model(p) for p in tri] for tri in tris_enu]

            # 2) TILE vertices for BV/quadtree (Z-up) = rotate model by +90Â° about X
            tris_tile = [[rotate_yup_to_zup(p) for p in tri] for tri in tris_model]

            # Root bounds for quadtree in TILE space (X-Y horizontal)
            xmin = min(v[0] for tri in tris_tile for v in tri)
            xmax = max(v[0] for tri in tris_tile for v in tri)
            ymin = min(v[1] for tri in tris_tile for v in tri)
            ymax = max(v[1] for tri in tris_tile for v in tri)
            root_bounds = (xmin, ymin, xmax, ymax)

            # Build quadtree using TILE (Z-up) tris and XY centroid
            root = build_quadtree(tris_tile, root_bounds, MAX_TRIS_PER_TILE, MAX_DEPTH)

            # IMPORTANT: Use Z-up transform at the root: columns [E, N, U]
            transform = enu_to_ecef_transform(lon0, lat0, h0)

            # Geometric error from horizontal XY span
            root_diag = math.hypot(xmax - xmin, ymax - ymin)
            root_ge = max(root_diag, 1.0)

            def emit_tile(node: TileNode, parent_ge: float) -> Optional[dict]:
                ge = parent_ge / 2.0 if node.level > 0 else parent_ge
                children_json = []
                content_uri = None

                if not node.children and node.tri_ids:
                    # Build submeshes separately:
                    # - verts_model for GLB (Y-up)
                    # - verts_tile  for BV (Z-up)
                    verts_model, faces = submesh_for_tile(tris_model, node.tri_ids)
                    if not faces:
                        return None

                    # For GLB authored Y-up, flip winding against Y
                    faces = flip_winding_if_needed(verts_model, faces, up_axis='Y')
                    norms = compute_normals(verts_model, faces)

                    subdir = os.path.join(OUT_DIR, TILES_DIR, str(node.level), str(node.ix), str(node.iy))
                    glb_path = os.path.join(subdir, "tile.glb")
                    write_glb(glb_path, verts_model, norms, faces)
                    content_uri = os.path.relpath(glb_path, OUT_DIR).replace("\\", "/")

                    # Bounding box must be in TILE (Z-up) space
                    verts_tile, _ = submesh_for_tile(tris_tile, node.tri_ids)
                    aabb = aabb_of_vertices(verts_tile)
                    box = box_from_aabb(aabb)

                else:
                    for c in node.children:
                        cj = emit_tile(c, ge)
                        if cj is not None:
                            children_json.append(cj)
                    if not children_json:
                        return None

                    # Union child boxes (already in TILE/Z-up space)
                    mins = [];
                    maxs = []
                    for ch in children_json:
                        bx = ch["boundingVolume"]["box"]
                        cx, cy, cz, hxx, hxy, hxz, hyx, hyy, hyz, hzx, hzy, hzz = bx
                        xmin_c = cx - abs(hxx) - abs(hyx) - abs(hzx)
                        xmax_c = cx + abs(hxx) + abs(hyx) + abs(hzx)
                        ymin_c = cy - abs(hxy) - abs(hyy) - abs(hzy)
                        ymax_c = cy + abs(hxy) + abs(hyy) + abs(hzy)
                        zmin_c = cz - abs(hxz) - abs(hyz) - abs(hzz)
                        zmax_c = cz + abs(hxz) + abs(hyz) + abs(hzz)
                        mins.append((xmin_c, ymin_c, zmin_c))
                        maxs.append((xmax_c, ymax_c, zmax_c))
                    xmin_u = min(m[0] for m in mins);
                    ymin_u = min(m[1] for m in mins);
                    zmin_u = min(m[2] for m in mins)
                    xmax_u = max(m[0] for m in maxs);
                    ymax_u = max(m[1] for m in maxs);
                    zmax_u = max(m[2] for m in maxs)
                    box = box_from_aabb((xmin_u, ymin_u, zmin_u, xmax_u, ymax_u, zmax_u))

                tile = {
                    "boundingVolume": {"box": box},
                    "geometricError": 0.0 if not children_json else ge,
                    "refine": "REPLACE"
                }
                if content_uri:
                    tile["content"] = {"uri": content_uri}
                if children_json:
                    tile["children"] = children_json
                return tile

            root_tile = emit_tile(root, root_ge)

            tileset = {
                "asset": {"version": "1.1"},
                "geometricError": root_ge,
                "root": {
                    "transform": transform,  # columns [E, N, U]
                    "boundingVolume": root_tile["boundingVolume"],
                    "geometricError": root_tile.get("geometricError", 0.0),
                    "refine": "REPLACE",
                    **({"content": root_tile["content"]} if "content" in root_tile else {}),
                    **({"children": root_tile["children"]} if "children" in root_tile else {})
                }
            }

            os.makedirs(OUT_DIR, exist_ok=True)
            tileset_path = os.path.join(OUT_DIR, ROOT_TILE_FILENAME)
            write_tileset_json(tileset_path, tileset)

            print(f"Tileset written to: {os.path.join(OUT_DIR, ROOT_TILE_FILENAME)}")
