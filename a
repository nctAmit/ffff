#!/usr/bin/env python3
# TIN (lon,lat,height) -> Cesium 3D Tiles (.b3dm) with quadtree tiling.
# Pure Python. No external tools. Robust traversal & visibility.

import json, os, math, struct
from collections import deque

# -------------------- Tunables --------------------
MAX_TRIANGLES_PER_TILE = 4000     # quadtree leaf threshold
MAX_DEPTH = 6                     # quadtree cap
WRITE_B3DM = True                 # False => write .glb tile content (3D Tiles 1.1+)
INDEX_UINT_SIZE = 4               # 2 or 4; 4 is safest

# traversal / culling safety
REGION_PAD_BOTTOM_M = 5.0
REGION_PAD_TOP_M = 50.0

# geometricError = clamp( extent_m * SCALE , MIN )
GE_SCALE = 0.75                   # 0.5â€“1.0 typical
GE_MIN = 0.25                     # never 0; small values block refinement

WRITE_WIREFRAME = True            # write LINES content alongside triangles (debug)
WRITE_STANDALONE_GLBS = True      # write _ALL_TRIANGLES.glb and _ALL_WIREFRAME.glb

# ------------------ Earth model -------------------
WGS84_A = 6378137.0
WGS84_B = 6356752.314245
WGS84_E2 = 1.0 - (WGS84_B*WGS84_B) / (WGS84_A*WGS84_A)
EARTH_RADIUS_MEAN = 6371008.8

def deg2rad(d): return d * math.pi / 180.0

def geodetic_to_ecef(lon_deg, lat_deg, h):
    lon = deg2rad(lon_deg); lat = deg2rad(lat_deg)
    cos_lat = math.cos(lat); sin_lat = math.sin(lat)
    N = WGS84_A / math.sqrt(1.0 - WGS84_E2 * sin_lat*sin_lat)
    x = (N + h) * cos_lat * math.cos(lon)
    y = (N + h) * cos_lat * math.sin(lon)
    z = (N*(1.0 - WGS84_E2) + h) * sin_lat
    return (x, y, z)

def ecef_to_enu_rows(lon_deg, lat_deg):
    lon = deg2rad(lon_deg); lat = deg2rad(lat_deg)
    sL, cL = math.sin(lon), math.cos(lon)
    sB, cB = math.sin(lat), math.cos(lat)
    return (
        (-sL,       cL,       0.0),        # E
        (-sB*cL,   -sB*sL,    cB),         # N
        ( cB*cL,    cB*sL,    sB),         # U
    )

def enu_to_ecef_transform(lon_deg, lat_deg, origin_ecef):
    lon = deg2rad(lon_deg); lat = deg2rad(lat_deg)
    sL, cL = math.sin(lon), math.cos(lon)
    sB, cB = math.sin(lat), math.cos(lat)
    Ex, Ey, Ez = -sL,        cL,       0.0
    Nx, Ny, Nz = -sB*cL,    -sB*sL,    cB
    Ux, Uy, Uz =  cB*cL,     cB*sL,    sB
    ox, oy, oz = origin_ecef
    return [
        Ex, Nx, Ux, 0.0,
        Ey, Ny, Uy, 0.0,
        Ez, Nz, Uz, 0.0,
        ox, oy, oz, 1.0
    ]

# ------------------ Helpers -----------------------
def flatten_tin(nested):
    pts = []
    def walk(x):
        if isinstance(x, (list, tuple)):
            if len(x)==3 and all(isinstance(v,(int,float)) for v in x):
                pts.append((float(x[0]), float(x[1]), float(x[2])))
            else:
                for e in x: walk(e)
    walk(nested)
    if len(pts) % 3: pts = pts[:len(pts) - (len(pts)%3)]
    tris = []
    for i in range(0, len(pts), 3):
        a,b,c = pts[i], pts[i+1], pts[i+2]
        tris.append((a,b,c))
    return tris

def tri_centroid_lonlat(tri):
    (l1,b1,h1),(l2,b2,h2),(l3,b3,h3) = tri
    return ((l1+l2+l3)/3.0, (b1+b2+b3)/3.0, (h1+h2+h3)/3.0)

def lonlat_bounds(tris):
    w=1e9; s=1e9; e=-1e9; n=-1e9; hmin=1e12; hmax=-1e12
    for t in tris:
        for (lon,lat,h) in t:
            w=min(w,lon); e=max(e,lon)
            s=min(s,lat); n=max(n,lat)
            hmin=min(hmin,h); hmax=max(hmax,h)
    return w,s,e,n,hmin,hmax

def haversine(lon1,lat1,lon2,lat2):
    lon1,lat1,lon2,lat2 = map(deg2rad,(lon1,lat1,lon2,lat2))
    dlon=lon2-lon1; dlat=lat2-lat1
    a = math.sin(dlat/2)**2 + math.cos(lat1)*math.cos(lat2)*math.sin(dlon/2)**2
    return 2*EARTH_RADIUS_MEAN*math.atan2(math.sqrt(a), math.sqrt(1-a))

def ground_extent_meters(w,s,e,n):
    w_m = haversine(w,(s+n)/2, e,(s+n)/2)
    h_m = haversine((w+e)/2, s, (w+e)/2, n)
    return max(w_m, h_m)

def compute_normals(positions, indices):
    n=len(positions); nx=[0.0]*n; ny=[0.0]*n; nz=[0.0]*n
    for i in range(0,len(indices),3):
        i0,i1,i2 = indices[i],indices[i+1],indices[i+2]
        x0,y0,z0 = positions[i0]
        x1,y1,z1 = positions[i1]
        x2,y2,z2 = positions[i2]
        ux,uy,uz = (x1-x0,y1-y0,z1-z0)
        vx,vy,vz = (x2-x0,y2-y0,z2-z0)
        fx = uy*vz - uz*vy
        fy = uz*vx - ux*vz
        fz = ux*vy - uy*vx
        nx[i0]+=fx; ny[i0]+=fy; nz[i0]+=fz
        nx[i1]+=fx; ny[i1]+=fy; nz[i1]+=fz
        nx[i2]+=fx; ny[i2]+=fy; nz[i2]+=fz
    out=[]
    for i in range(n):
        L=math.sqrt(nx[i]*nx[i]+ny[i]*ny[i]+nz[i]*nz[i]) or 1.0
        out.append((nx[i]/L, ny[i]/L, nz[i]/L))
    return out

# ----------------- glTF / GLB ---------------------
def _pad4(b): return b + (b' ' * ((4 - (len(b)%4))%4))

def make_glb(local_positions, indices, normals=None, mode=4):
    """
    mode: 4 = TRIANGLES, 1 = LINES
    """
    if normals is None:
        normals = compute_normals(local_positions, indices)

    pos_bytes = b''.join(struct.pack('<fff', *p) for p in local_positions)
    nor_bytes = b''.join(struct.pack('<fff', *n) for n in normals)

    if INDEX_UINT_SIZE==2:
        maxi = max(indices) if indices else 0
        if maxi>65535: raise ValueError("Use INDEX_UINT_SIZE=4 for large meshes")
        idx_bytes = b''.join(struct.pack('<H', i) for i in indices)
        ctype = 5123  # UNSIGNED_SHORT
    else:
        idx_bytes = b''.join(struct.pack('<I', i) for i in indices)
        ctype = 5125  # UNSIGNED_INT

    bin_data = pos_bytes + nor_bytes + idx_bytes

    bufferViews=[]; accessors=[]
    def add_bv(off, length, target):
        bufferViews.append({"buffer":0,"byteOffset":off,"byteLength":length,"target":target})
        return len(bufferViews)-1

    # positions
    off_pos = 0
    bv_pos = add_bv(off_pos, len(pos_bytes), 34962)   # ARRAY_BUFFER
    accessors.append({
        "bufferView": bv_pos, "byteOffset": 0, "componentType": 5126, "count": len(local_positions), "type":"VEC3",
        "min":[min(p[i] for p in local_positions) for i in range(3)],
        "max":[max(p[i] for p in local_positions) for i in range(3)],
    })

    # normals
    off_nor = off_pos + len(pos_bytes)
    bv_nor = add_bv(off_nor, len(nor_bytes), 34962)
    accessors.append({
        "bufferView": bv_nor, "byteOffset": 0, "componentType": 5126, "count": len(normals), "type":"VEC3"
    })

    # indices
    off_idx = off_nor + len(nor_bytes)
    bv_idx = add_bv(off_idx, len(idx_bytes), 34963)   # ELEMENT_ARRAY_BUFFER
    accessors.append({
        "bufferView": bv_idx, "byteOffset": 0, "componentType": ctype, "count": len(indices), "type":"SCALAR"
    })

    gltf = {
        "asset":{"version":"2.0"},
        "buffers":[{"byteLength": len(bin_data)}],
        "bufferViews": bufferViews,
        "accessors": accessors,
        "materials":[{
            "doubleSided": True,
            "pbrMetallicRoughness": {
                "baseColorFactor": [0.87,0.87,0.87,1.0],
                "metallicFactor": 0.0,
                "roughnessFactor": 1.0
            }
        }],
        "meshes":[{"primitives":[{
            "attributes":{"POSITION":0,"NORMAL":1},
            "indices":2, "mode": mode, "material":0
        }]}],
        "nodes":[{"mesh":0}],
        "scenes":[{"nodes":[0]}],
        "scene":0
    }

    gltf_json = json.dumps(gltf, separators=(',',':')).encode('utf-8')
    gltf_json_padded = _pad4(gltf_json)
    bin_padded = _pad4(bin_data)
    total_len = 12 + 8 + len(gltf_json_padded) + 8 + len(bin_padded)

    glb = []
    glb.append(struct.pack('<I',0x46546C67))  # 'glTF'
    glb.append(struct.pack('<I',2))
    glb.append(struct.pack('<I',total_len))
    glb.append(struct.pack('<I',len(gltf_json_padded)))
    glb.append(struct.pack('<I',0x4E4F534A))  # 'JSON'
    glb.append(gltf_json_padded)
    glb.append(struct.pack('<I',len(bin_padded)))
    glb.append(struct.pack('<I',0x004E4942))  # 'BIN\0'
    glb.append(bin_padded)
    return b''.join(glb)

def wrap_b3dm(glb_bytes, feature_table_json=None, batch_table_json=None):
    if feature_table_json is None:
        feature_table_json = {"BATCH_LENGTH": 0}
    ft = json.dumps(feature_table_json, separators=(',',':')).encode('utf-8')
    bt = json.dumps(batch_table_json or {}, separators=(',',':')).encode('utf-8')
    ftb=_pad4(ft); btb=_pad4(bt)
    header_len=28
    byteLength = header_len + len(ftb) + len(btb) + len(glb_bytes)
    header = struct.pack('<4sIIIIII', b'b3dm', 1, byteLength, len(ftb), 0, len(btb), 0)
    return header + ftb + btb + glb_bytes

# ----------------- Quadtree -----------------------
class Node:
    __slots__=("w","s","e","n","d","id","tris","kids","tri_count_subtree")
    def __init__(self, w,s,e,n, d, id_):
        self.w=w; self.s=s; self.e=e; self.n=n
        self.d=d; self.id=id_
        self.tris=[]; self.kids=None
        self.tri_count_subtree=0

def subdivide(root, max_tris, max_depth):
    q = deque([root])
    while q:
        node = q.popleft()
        if node.d >= max_depth or len(node.tris) <= max_tris:
            continue
        w,s,e,n = node.w,node.s,node.e,node.n
        cx=(w+e)/2.0; cy=(s+n)/2.0
        kids = [
            Node(w, cy, cx, n, node.d+1, node.id+"0"), # NW
            Node(cx,cy, e, n, node.d+1, node.id+"1"),  # NE
            Node(w, s, cx, cy, node.d+1, node.id+"2"), # SW
            Node(cx,s, e, cy, node.d+1, node.id+"3"),  # SE
        ]
        bins=[[],[],[],[]]
        for tri in node.tris:
            clon,clat,_ = tri_centroid_lonlat(tri)
            idx = (0 if clat>=cy and clon<cx else
                   1 if clat>=cy and clon>=cx else
                   2 if clat<cy  and clon<cx else 3)
            bins[idx].append(tri)
        for i,k in enumerate(kids): k.tris = bins[i]
        node.kids = kids
        node.tris = []
        q.extend(kids)

    # populate subtree triangle counts
    def count_tris(n: Node):
        if n.kids is None:
            n.tri_count_subtree = len(n.tris)
        else:
            total = 0
            for k in n.kids:
                total += count_tris(k)
            n.tri_count_subtree = total
        return n.tri_count_subtree
    count_tris(root)

def sample_from_subtree(node: Node, limit: int):
    """Collect up to 'limit' triangles from leaves in this subtree."""
    out=[]; stack=[node]
    while stack and len(out)<limit:
        cur = stack.pop()
        if cur.kids is None:
            if cur.tris:
                step=max(1, len(cur.tris) // max(1, limit // 4))
                out.extend(cur.tris[::step])
        else:
            # push larger subtrees first
            ks = sorted(cur.kids, key=lambda k: k.tri_count_subtree, reverse=True)
            stack.extend(ks)
    return out[:limit]

# -------------- Mesh builders / writers -----------
def build_local_mesh(tris, lon0, lat0, origin_ecef):
    R = ecef_to_enu_rows(lon0, lat0)
    verts=[]; vmap={}; idx=[]; edges=set()
    def to_enu(lon,lat,h):
        pe=geodetic_to_ecef(lon,lat,h)
        dx=pe[0]-origin_ecef[0]; dy=pe[1]-origin_ecef[1]; dz=pe[2]-origin_ecef[2]
        ex = R[0][0]*dx + R[0][1]*dy + R[0][2]*dz
        ny = R[1][0]*dx + R[1][1]*dy + R[1][2]*dz
        uz = R[2][0]*dx + R[2][1]*dy + R[2][2]*dz
        return (ex,ny,uz)
    def add_v(v):
        if v in vmap: return vmap[v]
        p = to_enu(*v); i=len(verts); verts.append(p); vmap[v]=i; return i
    for a,b,c in tris:
        i0=add_v(a); i1=add_v(b); i2=add_v(c)
        # CCW in ENU (z-up): ensure +Z normal
        x0,y0,z0=verts[i0]; x1,y1,z1=verts[i1]; x2,y2,z2=verts[i2]
        ux,uy,uz=(x1-x0,y1-y0,z1-z0); vx,vy,vz=(x2-x0,y2-y0,z2-z0)
        fz = ux*vy - uy*vx
        if fz < 0.0:
            i1,i2 = i2,i1
        idx.extend([i0,i1,i2])
        e0=tuple(sorted((i0,i1))); e1=tuple(sorted((i1,i2))); e2=tuple(sorted((i2,i0)))
        edges.add(e0); edges.add(e1); edges.add(e2)
    # line indices for wireframe
    lines=[]
    for a,b in edges:
        lines.extend([a,b])
    return verts, idx, lines

def write_tile_files(tile_dir, node: Node, tris, add_wire):
    if not tris: return None
    w,s,e,n = node.w,node.s,node.e,node.n
    lon0=(w+e)/2.0; lat0=(s+n)/2.0
    hs=[h for t in tris for (_,_,h) in t]
    h0 = sorted(hs)[len(hs)//2] if hs else 0.0

    origin_ecef = geodetic_to_ecef(lon0, lat0, h0)
    verts, tri_idx, line_idx = build_local_mesh(tris, lon0, lat0, origin_ecef)

    glb_tri = make_glb(verts, tri_idx, normals=None, mode=4)
    if WRITE_B3DM:
        payload = wrap_b3dm(glb_tri); ext=".b3dm"
    else:
        payload = glb_tri; ext=".glb"
    fname = f"tile_{node.id or 'root'}{ext}"
    with open(os.path.join(tile_dir, fname), "wb") as f: f.write(payload)

    wire_uri = None
    if add_wire and line_idx:
        glb_lin = make_glb(verts, line_idx, normals=[(0,0,1)]*len(verts), mode=1)
        wire_payload = wrap_b3dm(glb_lin) if WRITE_B3DM else glb_lin
        wire_uri = f"tile_{node.id or 'root'}_wire{ext}"
        with open(os.path.join(tile_dir, wire_uri), "wb") as f: f.write(wire_payload)

    west_r,south_r,east_r,north_r = map(deg2rad, (w,s,e,n))
    hmin_p = (min(hs) if hs else h0) - REGION_PAD_BOTTOM_M
    hmax_p = (max(hs) if hs else h0) + REGION_PAD_TOP_M
    extent_m = max(ground_extent_meters(w,s,e,n), 1.0)
    ge = max(extent_m * GE_SCALE, GE_MIN)

    return {
        "uri": fname,
        "wire_uri": wire_uri,
        "transform": enu_to_ecef_transform(lon0,lat0,origin_ecef),
        "region": [west_r,south_r,east_r,north_r,hmin_p,hmax_p],
        "ge": ge
    }

def build_tileset(root: Node, out_dir):
    tiles_dir = os.path.join(out_dir, "tiles")
    os.makedirs(tiles_dir, exist_ok=True)

    def build_json(node: Node):
        # choose content tris for this node
        if node.kids is None:
            tris_here = node.tris
        else:
            # internal node: always sample from subtree (guaranteed non-empty if subtree has tris)
            want = max(100, min(5000, node.tri_count_subtree // 10 or 100))
            tris_here = sample_from_subtree(node, want)

        info = write_tile_files(tiles_dir, node, tris_here, add_wire=WRITE_WIREFRAME)
        # fallback empty (rare)
        if info is None:
            region=[*map(deg2rad,(node.w,node.s,node.e,node.n)), 0.0, 10.0]
            ge_here = max(ground_extent_meters(node.w,node.s,node.e,node.n) * GE_SCALE, GE_MIN)
            out = {"boundingVolume":{"region":region}, "geometricError": ge_here, "refine":"REPLACE"}
        else:
            out = {
                "boundingVolume":{"region": info["region"]},
                "geometricError": max(info["ge"], GE_MIN),
                "refine":"REPLACE",
                "transform": info["transform"],
                "content":{"uri":"tiles/"+info["uri"]}
            }
            if info["wire_uri"]:
                out.setdefault("children", []).append({
                    "boundingVolume":{"region": info["region"]},
                    "geometricError": GE_MIN,
                    "refine":"REPLACE",
                    "transform": info["transform"],
                    "content":{"uri":"tiles/"+info["wire_uri"]}
                })

        # children
        if node.kids:
            kids_json = [build_json(k) for k in node.kids]
            out.setdefault("children", []).extend(kids_json)

            # keep parent GE â‰¥ max(child GE)
            max_child_ge = max(k.get("geometricError", GE_MIN) for k in kids_json)
            out["geometricError"] = max(out["geometricError"], max_child_ge)

        return out

    root_json = build_json(root)
    root_extent_m = max(ground_extent_meters(root.w,root.s,root.e,root.n), 1.0)
    tileset = {
        "asset":{"version":"1.0"},
        "geometricError": max(root_extent_m * GE_SCALE, GE_MIN),
        "root": root_json
    }
    with open(os.path.join(out_dir, "tileset.json"), "w", encoding="utf-8") as f:
        json.dump(tileset, f, separators=(',',':'))
    return tileset

# ----------------- Public API / Main ---------------
def tin_to_3dtiles(tin_nested, output_dir):
    os.makedirs(output_dir, exist_ok=True)
    tris = flatten_tin(tin_nested)
    if not tris:
        raise ValueError("No triangles parsed from input.")

    w,s,e,n,hmin,hmax = lonlat_bounds(tris)
    root = Node(w,s,e,n, 0, "")
    root.tris = tris
    subdivide(root, MAX_TRIANGLES_PER_TILE, MAX_DEPTH)

    # dump standalone GLBs (sanity) from full mesh at area center
    if WRITE_STANDALONE_GLBS:
        lon0=(w+e)/2.0; lat0=(s+n)/2.0
        hs=[h for t in tris for (_,_,h) in t]; h0 = sorted(hs)[len(hs)//2] if hs else 0.0
        origin_ecef=geodetic_to_ecef(lon0,lat0,h0)
        verts, tri_idx, line_idx = build_local_mesh(tris, lon0, lat0, origin_ecef)
        glb_tri = make_glb(verts, tri_idx, normals=None, mode=4)
        with open(os.path.join(output_dir,"_ALL_TRIANGLES.glb"),"wb") as f: f.write(glb_tri)
        glb_lin = make_glb(verts, line_idx, normals=[(0,0,1)]*len(verts), mode=1)
        with open(os.path.join(output_dir,"_ALL_WIREFRAME.glb"),"wb") as f: f.write(glb_lin)

    return build_tileset(root, output_dir)

# --------------- Example run -----------------------
if __name__ == "__main__":
    # Replace this with your real nested TIN data
    TIN_DATA = [
        [[[77.2090, 28.6139, 230.0], [77.2095, 28.6142, 232.0], [77.2086, 28.6140, 231.0]]],
        [[[77.2096, 28.6145, 233.0], [77.2090, 28.6139, 230.0], [77.2100, 28.6142, 229.0]]]
    ]
    OUTPUT_DIR = "./tin_tiles_out"
    tileset = tin_to_3dtiles(TIN_DATA, OUTPUT_DIR)
    print("Wrote:", os.path.abspath(os.path.join(OUTPUT_DIR, "tileset.json")))
    print("Tiles:", os.path.abspath(os.path.join(OUTPUT_DIR, "tiles")))
    if WRITE_STANDALONE_GLBS:
        print("Debug GLBs:", os.path.abspath(os.path.join(OUTPUT_DIR,"_ALL_TRIANGLES.glb")),
              os.path.abspath(os.path.join(OUTPUT_DIR,"_ALL_WIREFRAME.glb")))
